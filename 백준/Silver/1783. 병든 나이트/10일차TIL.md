## 📌 문제: 병든 나이트 - 1783

처음에는 DFS나 BFS 같은 탐색 알고리즘을 떠올렸지만, **최단거리**가 아닌 **특정 조건에 따른 최대 이동 칸 수**를 구하는 문제라는 것을 파악하고  **규칙성**을 이용하는 방식으로 전환했다.

---

### 🔍 접근 방식 요약

1. **기본 개념**
    - 나이트는 체스판에서 특정한 4가지 방식만 이동 가능.
    - 방문한 칸 수를 최대로 하면서도, 4번 이상 움직이면 4가지 이동 방법을 모두 사용해야 함.
2. **판 크기에 따른 분기 처리**
    - `N === 1` (세로 1칸): 상하 이동이 불가능 → 현재 칸 외 이동 불가 → **정답: 1**
    - `N === 2` (세로 2칸): 이동 제한으로 최대 사용 가능한 이동 방식은 2번, 3번 뿐
        
        → `Math.min(4, Math.floor((M + 1) / 2))`
        
    - `N >= 3` (세로 3칸 이상): 상하이동 가능
        - `M < 7`이면 4가지 방법 모두 사용은 불가 → 이동방식 1번,4번을 이용하는 것이 제일 유리한 방법 `Math.min(4, M)`
        - `M >= 7`이면 충분히 다양한 경로 가능 → **이동 제한 없이** `M - 2`

---

```jsx
const [N, M] = require("fs")
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split(" ")
  .map(Number);

if (N === 1) {
  console.log(1);
} else if (N === 2) {
  console.log(Math.min(4, Math.floor((M + 1) / 2)));
} else if (N >= 3) {
  if (M <= 6) {
    console.log(Math.min(4, M));
  } else {
    console.log(M - 2);
  }
}

```

---
### 💡 느낀 점

처음에 DFS나 BFS에 집착했지만, 문제의 본질을 파악하는 것이 더 중요하다는 것을 다시 한번 느꼈다.

다양한 조건에 따라 분기 처리하는 방식이 실무에서도 유용하게 쓰일 수 있겠다는 생각이 들었다.
